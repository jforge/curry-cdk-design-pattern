"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const logging_1 = require("./logging");
const os_1 = require("./os");
/**
 * Build and upload a Docker image
 *
 * Permanently identifying images is a bit of a bust. Newer Docker version use
 * a digest (sha256:xxxx) as an image identifier, which is pretty good to avoid
 * spurious rebuilds. However, this digest is calculated over a manifest that
 * includes metadata that is liable to change. For example, as soon as we
 * push the Docker image to a repository, the digest changes. This makes the
 * digest worthless to determe whether we already pushed an image, for example.
 *
 * As a workaround, we calculate our own digest over parts of the manifest that
 * are unlikely to change, and tag based on that.
 *
 * When running in CI, we pull the latest image first and use it as cache for
 * the build. Generally pulling will be faster than building, especially for
 * Dockerfiles with lots of OS/code packages installation or changes only in
 * the bottom layers. When running locally chances are that we already have
 * layers cache available.
 *
 * CI is detected by the presence of the `CI` environment variable or
 * the `--ci` command line option.
 */
async function prepareContainerAsset(assemblyDir, asset, toolkitInfo, reuse, ci) {
    if (reuse) {
        return [
            { ParameterKey: asset.imageNameParameter, UsePreviousValue: true },
        ];
    }
    const contextPath = path.isAbsolute(asset.path) ? asset.path : path.join(assemblyDir, asset.path);
    logging_1.debug(' ðŸ‘‘  Preparing Docker image asset:', contextPath);
    try {
        const ecr = await toolkitInfo.prepareEcrRepository(asset);
        const latest = `${ecr.repositoryUri}:latest`;
        let loggedIn = false;
        // In CI we try to pull latest first
        if (ci) {
            await dockerLogin(toolkitInfo);
            loggedIn = true;
            try {
                await os_1.shell(['docker', 'pull', latest]);
            }
            catch (e) {
                logging_1.debug('Failed to pull latest image from ECR repository');
            }
        }
        const buildArgs = [].concat(...Object.entries(asset.buildArgs || {}).map(([k, v]) => ['--build-arg', `${k}=${v}`]));
        const baseCommand = [
            'docker', 'build',
            ...buildArgs,
            '--tag', latest,
            contextPath
        ];
        if (asset.target) {
            baseCommand.push('--target', asset.target);
        }
        if (asset.file) {
            baseCommand.push('--file', asset.file);
        }
        const command = ci
            ? [...baseCommand, '--cache-from', latest] // This does not fail if latest is not available
            : baseCommand;
        await os_1.shell(command);
        // Login and push
        if (!loggedIn) { // We could be already logged in if in CI
            await dockerLogin(toolkitInfo);
            loggedIn = true;
        }
        // There's no way to make this quiet, so we can't use a PleaseHold. Print a header message.
        logging_1.print(` âŒ› Pushing Docker image for ${contextPath}; this may take a while.`);
        await os_1.shell(['docker', 'push', latest]);
        logging_1.debug(` ðŸ‘‘  Docker image for ${contextPath} pushed.`);
        // Get the (single) repo-digest for latest, which'll be <ecr.repositoryUrl>@sha256:<repoImageSha256>
        const repoDigests = (await os_1.shell(['docker', 'image', 'inspect', latest, '--format', '{{range .RepoDigests}}{{.}}|{{end}}'])).trim();
        const requiredPrefix = `${ecr.repositoryUri}@sha256:`;
        const repoDigest = repoDigests.split('|').find(digest => digest.startsWith(requiredPrefix));
        if (!repoDigest) {
            throw new Error(`Unable to identify repository digest (none starts with ${requiredPrefix}) in:\n${repoDigests}`);
        }
        return [
            { ParameterKey: asset.imageNameParameter, ParameterValue: repoDigest.replace(ecr.repositoryUri, ecr.repositoryName) },
        ];
    }
    catch (e) {
        if (e.code === 'ENOENT') {
            // tslint:disable-next-line:max-line-length
            throw new Error('Error building Docker image asset; you need to have Docker installed in order to be able to build image assets. Please install Docker and try again.');
        }
        throw e;
    }
}
exports.prepareContainerAsset = prepareContainerAsset;
/**
 * Get credentials from ECR and run docker login
 */
async function dockerLogin(toolkitInfo) {
    const credentials = await toolkitInfo.getEcrCredentials();
    await os_1.shell(['docker', 'login',
        '--username', credentials.username,
        '--password', credentials.password,
        credentials.endpoint]);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG9ja2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZG9ja2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUEsNkJBQTZCO0FBRTdCLHVDQUF5QztBQUN6Qyw2QkFBNkI7QUFFN0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFCRztBQUNJLEtBQUssVUFBVSxxQkFBcUIsQ0FBQyxXQUFtQixFQUNuQixLQUF1QyxFQUN2QyxXQUF3QixFQUN4QixLQUFjLEVBQ2QsRUFBWTtJQUV0RCxJQUFJLEtBQUssRUFBRTtRQUNULE9BQU87WUFDTCxFQUFFLFlBQVksRUFBRSxLQUFLLENBQUMsa0JBQWtCLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFO1NBQ25FLENBQUM7S0FDSDtJQUVELE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFbEcsZUFBSyxDQUFDLG9DQUFvQyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBRXpELElBQUk7UUFDRixNQUFNLEdBQUcsR0FBRyxNQUFNLFdBQVcsQ0FBQyxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMxRCxNQUFNLE1BQU0sR0FBRyxHQUFHLEdBQUcsQ0FBQyxhQUFhLFNBQVMsQ0FBQztRQUU3QyxJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUM7UUFFckIsb0NBQW9DO1FBQ3BDLElBQUksRUFBRSxFQUFFO1lBQ04sTUFBTSxXQUFXLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDL0IsUUFBUSxHQUFHLElBQUksQ0FBQztZQUVoQixJQUFJO2dCQUNGLE1BQU0sVUFBSyxDQUFDLENBQUMsUUFBUSxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO2FBQ3pDO1lBQUMsT0FB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TUFBTSxXQUFXLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztJQUMxRCxNQUFNLFVBQUssQ0FBQyxDQUFDLFFBQVEsRUFBRSxPQUFPO1FBQzlCLFlBQVksRUFBRSxXQUFXLENBQUMsUUFBUTtRQUNsQyxZQUFZLEVBQUUsV0FBVyxDQUFDLFFBQVE7UUFDbEMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7QUFDekIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbnRhaW5lckltYWdlQXNzZXRNZXRhZGF0YUVudHJ5IH0gZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCB7IENsb3VkRm9ybWF0aW9uIH0gZnJvbSAnYXdzLXNkayc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgVG9vbGtpdEluZm8gfSBmcm9tICcuL2FwaS90b29sa2l0LWluZm8nO1xuaW1wb3J0IHsgZGVidWcsIHByaW50IH0gZnJvbSAnLi9sb2dnaW5nJztcbmltcG9ydCB7IHNoZWxsIH0gZnJvbSAnLi9vcyc7XG5cbi8qKlxuICogQnVpbGQgYW5kIHVwbG9hZCBhIERvY2tlciBpbWFnZVxuICpcbiAqIFBlcm1hbmVudGx5IGlkZW50aWZ5aW5nIGltYWdlcyBpcyBhIGJpdCBvZiBhIGJ1c3QuIE5ld2VyIERvY2tlciB2ZXJzaW9uIHVzZVxuICogYSBkaWdlc3QgKHNoYTI1Njp4eHh4KSBhcyBhbiBpbWFnZSBpZGVudGlmaWVyLCB3aGljaCBpcyBwcmV0dHkgZ29vZCB0byBhdm9pZFxuICogc3B1cmlvdXMgcmVidWlsZHMuIEhvd2V2ZXIsIHRoaXMgZGlnZXN0IGlzIGNhbGN1bGF0ZWQgb3ZlciBhIG1hbmlmZXN0IHRoYXRcbiAqIGluY2x1ZGVzIG1ldGFkYXRhIHRoYXQgaXMgbGlhYmxlIHRvIGNoYW5nZS4gRm9yIGV4YW1wbGUsIGFzIHNvb24gYXMgd2VcbiAqIHB1c2ggdGhlIERvY2tlciBpbWFnZSB0byBhIHJlcG9zaXRvcnksIHRoZSBkaWdlc3QgY2hhbmdlcy4gVGhpcyBtYWtlcyB0aGVcbiAqIGRpZ2VzdCB3b3J0aGxlc3MgdG8gZGV0ZXJtZSB3aGV0aGVyIHdlIGFscmVhZHkgcHVzaGVkIGFuIGltYWdlLCBmb3IgZXhhbXBsZS5cbiAqXG4gKiBBcyBhIHdvcmthcm91bmQsIHdlIGNhbGN1bGF0ZSBvdXIgb3duIGRpZ2VzdCBvdmVyIHBhcnRzIG9mIHRoZSBtYW5pZmVzdCB0aGF0XG4gKiBhcmUgdW5saWtlbHkgdG8gY2hhbmdlLCBhbmQgdGFnIGJhc2VkIG9uIHRoYXQuXG4gKlxuICogV2hlbiBydW5uaW5nIGluIENJLCB3ZSBwdWxsIHRoZSBsYXRlc3QgaW1hZ2UgZmlyc3QgYW5kIHVzZSBpdCBhcyBjYWNoZSBmb3JcbiAqIHRoZSBidWlsZC4gR2VuZXJhbGx5IHB1bGxpbmcgd2lsbCBiZSBmYXN0ZXIgdGhhbiBidWlsZGluZywgZXNwZWNpYWxseSBmb3JcbiAqIERvY2tlcmZpbGVzIHdpdGggbG90cyBvZiBPUy9jb2RlIHBhY2thZ2VzIGluc3RhbGxhdGlvbiBvciBjaGFuZ2VzIG9ubHkgaW5cbiAqIHRoZSBib3R0b20gbGF5ZXJzLiBXaGVuIHJ1bm5pbmcgbG9jYWxseSBjaGFuY2VzIGFyZSB0aGF0IHdlIGFscmVhZHkgaGF2ZVxuICogbGF5ZXJzIGNhY2hlIGF2YWlsYWJsZS5cbiAqXG4gKiBDSSBpcyBkZXRlY3RlZCBieSB0aGUgcHJlc2VuY2Ugb2YgdGhlIGBDSWAgZW52aXJvbm1lbnQgdmFyaWFibGUgb3JcbiAqIHRoZSBgLS1jaWAgY29tbWFuZCBsaW5lIG9wdGlvbi5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByZXBhcmVDb250YWluZXJBc3NldChhc3NlbWJseURpcjogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NldDogQ29udGFpbmVySW1hZ2VBc3NldE1ldGFkYXRhRW50cnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xraXRJbmZvOiBUb29sa2l0SW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV1c2U6IGJvb2xlYW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNpPzogYm9vbGVhbik6IFByb21pc2U8W0Nsb3VkRm9ybWF0aW9uLlBhcmFtZXRlcl0+IHtcblxuICBpZiAocmV1c2UpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyBQYXJhbWV0ZXJLZXk6IGFzc2V0LmltYWdlTmFtZVBhcmFtZXRlciwgVXNlUHJldmlvdXNWYWx1ZTogdHJ1ZSB9LFxuICAgIF07XG4gIH1cblxuICBjb25zdCBjb250ZXh0UGF0aCA9IHBhdGguaXNBYnNvbHV0ZShhc3NldC5wYXRoKSA/IGFzc2V0LnBhdGggOiBwYXRoLmpvaW4oYXNzZW1ibHlEaXIsIGFzc2V0LnBhdGgpO1xuXG4gIGRlYnVnKCcg8J+RkSAgUHJlcGFyaW5nIERvY2tlciBpbWFnZSBhc3NldDonLCBjb250ZXh0UGF0aCk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBlY3IgPSBhd2FpdCB0b29sa2l0SW5mby5wcmVwYXJlRWNyUmVwb3NpdG9yeShhc3NldCk7XG4gICAgY29uc3QgbGF0ZXN0ID0gYCR7ZWNyLnJlcG9zaXRvcnlVcml9OmxhdGVzdGA7XG5cbiAgICBsZXQgbG9nZ2VkSW4gPSBmYWxzZTtcblxuICAgIC8vIEluIENJIHdlIHRyeSB0byBwdWxsIGxhdGVzdCBmaXJzdFxuICAgIGlmIChjaSkge1xuICAgICAgYXdhaXQgZG9ja2VyTG9naW4odG9vbGtpdEluZm8pO1xuICAgICAgbG9nZ2VkSW4gPSB0cnVlO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBzaGVsbChbJ2RvY2tlcicsICdwdWxsJywgbGF0ZXN0XSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGRlYnVnKCdGYWlsZWQgdG8gcHVsbCBsYXRlc3QgaW1hZ2UgZnJvbSBFQ1IgcmVwb3NpdG9yeScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGJ1aWxkQXJncyA9IChbXSBhcyBzdHJpbmdbXSkuY29uY2F0KC4uLk9iamVjdC5lbnRyaWVzKGFzc2V0LmJ1aWxkQXJncyB8fCB7fSkubWFwKChbaywgdl0pID0+IFsnLS1idWlsZC1hcmcnLCBgJHtrfT0ke3Z9YF0pKTtcblxuICAgIGNvbnN0IGJhc2VDb21tYW5kID0gW1xuICAgICAgJ2RvY2tlcicsICdidWlsZCcsXG4gICAgICAuLi5idWlsZEFyZ3MsXG4gICAgICAnLS10YWcnLCBsYXRlc3QsXG4gICAgICBjb250ZXh0UGF0aFxuICAgIF07XG5cbiAgICBpZiAoYXNzZXQudGFyZ2V0KSB7XG4gICAgICBiYXNlQ29tbWFuZC5wdXNoKCctLXRhcmdldCcsIGFzc2V0LnRhcmdldCk7XG4gICAgfVxuXG4gICAgaWYgKGFzc2V0LmZpbGUpIHtcbiAgICAgIGJhc2VDb21tYW5kLnB1c2goJy0tZmlsZScsIGFzc2V0LmZpbGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbW1hbmQgPSBjaVxuICAgICAgPyBbLi4uYmFzZUNvbW1hbmQsICctLWNhY2hlLWZyb20nLCBsYXRlc3RdIC8vIFRoaXMgZG9lcyBub3QgZmFpbCBpZiBsYXRlc3QgaXMgbm90IGF2YWlsYWJsZVxuICAgICAgOiBiYXNlQ29tbWFuZDtcbiAgICBhd2FpdCBzaGVsbChjb21tYW5kKTtcblxuICAgIC8vIExvZ2luIGFuZCBwdXNoXG4gICAgaWYgKCFsb2dnZWRJbikgeyAvLyBXZSBjb3VsZCBiZSBhbHJlYWR5IGxvZ2dlZCBpbiBpZiBpbiBDSVxuICAgICAgYXdhaXQgZG9ja2VyTG9naW4odG9vbGtpdEluZm8pO1xuICAgICAgbG9nZ2VkSW4gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIFRoZXJlJ3Mgbm8gd2F5IHRvIG1ha2UgdGhpcyBxdWlldCwgc28gd2UgY2FuJ3QgdXNlIGEgUGxlYXNlSG9sZC4gUHJpbnQgYSBoZWFkZXIgbWVzc2FnZS5cbiAgICBwcmludChgIOKMmyBQdXNoaW5nIERvY2tlciBpbWFnZSBmb3IgJHtjb250ZXh0UGF0aH07IHRoaXMgbWF5IHRha2UgYSB3aGlsZS5gKTtcbiAgICBhd2FpdCBzaGVsbChbJ2RvY2tlcicsICdwdXNoJywgbGF0ZXN0XSk7XG4gICAgZGVidWcoYCDwn5GRICBEb2NrZXIgaW1hZ2UgZm9yICR7Y29udGV4dFBhdGh9IHB1c2hlZC5gKTtcblxuICAgIC8vIEdldCB0aGUgKHNpbmdsZSkgcmVwby1kaWdlc3QgZm9yIGxhdGVzdCwgd2hpY2gnbGwgYmUgPGVjci5yZXBvc2l0b3J5VXJsPkBzaGEyNTY6PHJlcG9JbWFnZVNoYTI1Nj5cbiAgICBjb25zdCByZXBvRGlnZXN0cyA9IChhd2FpdCBzaGVsbChbJ2RvY2tlcicsICdpbWFnZScsICdpbnNwZWN0JywgbGF0ZXN0LCAnLS1mb3JtYXQnLCAne3tyYW5nZSAuUmVwb0RpZ2VzdHN9fXt7Ln19fHt7ZW5kfX0nXSkpLnRyaW0oKTtcbiAgICBjb25zdCByZXF1aXJlZFByZWZpeCA9IGAke2Vjci5yZXBvc2l0b3J5VXJpfUBzaGEyNTY6YDtcbiAgICBjb25zdCByZXBvRGlnZXN0ID0gcmVwb0RpZ2VzdHMuc3BsaXQoJ3wnKS5maW5kKGRpZ2VzdCA9PiBkaWdlc3Quc3RhcnRzV2l0aChyZXF1aXJlZFByZWZpeCkpO1xuICAgIGlmICghcmVwb0RpZ2VzdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gaWRlbnRpZnkgcmVwb3NpdG9yeSBkaWdlc3QgKG5vbmUgc3RhcnRzIHdpdGggJHtyZXF1aXJlZFByZWZpeH0pIGluOlxcbiR7cmVwb0RpZ2VzdHN9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtcbiAgICAgIHsgUGFyYW1ldGVyS2V5OiBhc3NldC5pbWFnZU5hbWVQYXJhbWV0ZXIsIFBhcmFtZXRlclZhbHVlOiByZXBvRGlnZXN0LnJlcGxhY2UoZWNyLnJlcG9zaXRvcnlVcmksIGVjci5yZXBvc2l0b3J5TmFtZSkgfSxcbiAgICBdO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgYnVpbGRpbmcgRG9ja2VyIGltYWdlIGFzc2V0OyB5b3UgbmVlZCB0byBoYXZlIERvY2tlciBpbnN0YWxsZWQgaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBidWlsZCBpbWFnZSBhc3NldHMuIFBsZWFzZSBpbnN0YWxsIERvY2tlciBhbmQgdHJ5IGFnYWluLicpO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9XG59XG5cbi8qKlxuICogR2V0IGNyZWRlbnRpYWxzIGZyb20gRUNSIGFuZCBydW4gZG9ja2VyIGxvZ2luXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRvY2tlckxvZ2luKHRvb2xraXRJbmZvOiBUb29sa2l0SW5mbykge1xuICBjb25zdCBjcmVkZW50aWFscyA9IGF3YWl0IHRvb2xraXRJbmZvLmdldEVjckNyZWRlbnRpYWxzKCk7XG4gIGF3YWl0IHNoZWxsKFsnZG9ja2VyJywgJ2xvZ2luJyxcbiAgJy0tdXNlcm5hbWUnLCBjcmVkZW50aWFscy51c2VybmFtZSxcbiAgJy0tcGFzc3dvcmQnLCBjcmVkZW50aWFscy5wYXNzd29yZCxcbiAgY3JlZGVudGlhbHMuZW5kcG9pbnRdKTtcbn1cbiJdfQ==