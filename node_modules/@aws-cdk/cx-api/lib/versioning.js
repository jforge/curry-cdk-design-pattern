"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const semver = require("semver");
// ----------------------------------------------------------------------
//
//   READ THIS FIRST WHEN CHANGING THIS FILE
//
// ----------------------------------------------------------------------
//
// You need (and only need) to bump the CLOUD_ASSEMBLY_VERSION if the cloud
// assembly needs new features from the CDK CLI. Examples: new fields, new
// behavior, new artifact types.
//
// If that happens, you set the CLOUD_ASSEMBLY_VERSION to the *next* (not the
// current!) CDK version that will be released. This is done to produce
// useful error messages.
//
// When you do this, you will force users of a new library to upgrade the CLI
// (good), but UNLESS YOU ALSO IMPLEMENT 'upgradeAssemblyManifest' you will also
// force people who have installed a newer CLI to upgrade their libraries (bad!).
// Do that too, unless you have a very good reason not to.
/**
 * Bump this to the library version if and only if the CX protocol changes.
 *
 * We could also have used 1, 2, 3, ... here to indicate protocol versions, but
 * those then still need to be mapped to software versions to be useful. So we
 * might as well use the software version as protocol version and immediately
 * generate a useful error message from this.
 *
 * Note that the versions are not compared in a semver way, they are used as
 * opaque ordered tokens.
 */
exports.CLOUD_ASSEMBLY_VERSION = '1.16.0';
/**
 * Look at the type of response we get and upgrade it to the latest expected version
 */
function verifyManifestVersion(manifetVersion) {
    const frameworkVersion = parseSemver(manifetVersion);
    const toolkitVersion = parseSemver(exports.CLOUD_ASSEMBLY_VERSION);
    // if framework > cli, we require a newer cli version
    if (semver.gt(frameworkVersion, toolkitVersion)) {
        throw new Error(`A newer version of the CDK CLI (>= ${frameworkVersion}) is necessary to interact with this app`);
    }
    // if framework < cli, we require a newer framework version
    if (semver.lt(frameworkVersion, toolkitVersion)) {
        throw new Error(`The CDK CLI you are using requires your app to use CDK modules with version >= ${exports.CLOUD_ASSEMBLY_VERSION}`);
    }
}
exports.verifyManifestVersion = verifyManifestVersion;
/**
 * Upgrade old manifest versions to later manifest version here (if possible).
 *
 * Use this to make the toolkit recognize old assembly versions. This function should
 * add newly required fields with appropriate default values, etc.
 */
function upgradeAssemblyManifest(manifest) {
    if (manifest.version === '0.36.0') {
        // Adding a new artifact type, old version will not have it so painless upgrade.
        manifest = justUpgradeVersion(manifest, '1.10.0');
    }
    if (manifest.version === '1.10.0') {
        // Two changes:
        // * Backwards-compatible changes to the VPC provider
        // * Added AMI context provider: old assemblies won't reference it.
        manifest = justUpgradeVersion(manifest, '1.16.0');
    }
    return manifest;
}
exports.upgradeAssemblyManifest = upgradeAssemblyManifest;
function parseSemver(version) {
    const ver = semver.coerce(version);
    if (!ver) {
        throw new Error(`Could not parse "${version}" as semver`);
    }
    return ver;
}
/**
 * Return a copy of the manifest with just the version field updated
 *
 * Useful if there are protocol changes that are automatically backwards
 * compatible.
 */
function justUpgradeVersion(manifest, version) {
    return Object.assign({}, manifest, { version });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVyc2lvbmluZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInZlcnNpb25pbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxpQ0FBaUM7QUFHakMseUVBQXlFO0FBQ3pFLEVBQUU7QUFDRiw0Q0FBNEM7QUFDNUMsRUFBRTtBQUNGLHlFQUF5RTtBQUN6RSxFQUFFO0FBQ0YsMkVBQTJFO0FBQzNFLDBFQUEwRTtBQUMxRSxnQ0FBZ0M7QUFDaEMsRUFBRTtBQUNGLDZFQUE2RTtBQUM3RSx1RUFBdUU7QUFDdkUseUJBQXlCO0FBQ3pCLEVBQUU7QUFDRiw2RUFBNkU7QUFDN0UsZ0ZBQWdGO0FBQ2hGLGlGQUFpRjtBQUNqRiwwREFBMEQ7QUFFMUQ7Ozs7Ozs7Ozs7R0FVRztBQUNVLFFBQUEsc0JBQXNCLEdBQUcsUUFBUSxDQUFDO0FBRS9DOztHQUVHO0FBQ0gsU0FBZ0IscUJBQXFCLENBQUMsY0FBc0I7SUFDMUQsTUFBTSxnQkFBZ0IsR0FBRyxXQUFXLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDckQsTUFBTSxjQUFjLEdBQUcsV0FBVyxDQUFDLDhCQUFzQixDQUFDLENBQUM7SUFFM0QscURBQXFEO0lBQ3JELElBQUksTUFBTSxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsRUFBRSxjQUFjLENBQUMsRUFBRTtRQUMvQyxNQUFNLElBQUksS0FBSyxDQUFDLHNDQUFzQyxnQkFBZ0IsMENBQTBDLENBQUMsQ0FBQztLQUNuSDtJQUVELDJEQUEyRDtJQUMzRCxJQUFJLE1BQU0sQ0FBQyxFQUFFLENBQUMsZ0JBQWdCLEVBQUUsY0FBYyxDQUFDLEVBQUU7UUFDL0MsTUFBTSxJQUFJLEtBQUssQ0FBQyxrRkFBa0YsOEJBQXNCLEVBQUUsQ0FBQyxDQUFDO0tBQzdIO0FBQ0gsQ0FBQztBQWJELHNEQWFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQix1QkFBdUIsQ0FBQyxRQUEwQjtJQUVoRSxJQUFJLFFBQVEsQ0FBQyxPQUFPLEtBQUssUUFBUSxFQUFFO1FBQ2pDLGdGQUFnRjtRQUNoRixRQUFRLEdBQUcsa0JBQWtCLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0tBQ25EO0lBRUQsSUFBSSxRQUFRLENBQUMsT0FBTyxLQUFLLFFBQVEsRUFBRTtRQUNqQyxlQUFlO1FBQ2YscURBQXFEO1FBQ3JELG1FQUFtRTtRQUNuRSxRQUFRLEdBQUcsa0JBQWtCLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0tBQ25EO0lBRUQsT0FBTyxRQUFRLENBQUM7QUFDbEIsQ0FBQztBQWZELDBEQWVDO0FBRUQsU0FBUyxXQUFXLENBQUMsT0FBZTtJQUNsQyxNQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ25DLElBQUksQ0FBQyxHQUFHLEVBQUU7UUFDUixNQUFNLElBQUksS0FBSyxDQUFDLG9CQUFvQixPQUFPLGFBQWEsQ0FBQyxDQUFDO0tBQzNEO0lBRUQsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFTLGtCQUFrQixDQUFDLFFBQTBCLEVBQUUsT0FBZTtJQUNyRSxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLFFBQVEsRUFBRSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7QUFDbEQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHNlbXZlciBmcm9tICdzZW12ZXInO1xuaW1wb3J0IHsgQXNzZW1ibHlNYW5pZmVzdCB9IGZyb20gJy4vY2xvdWQtYXNzZW1ibHknO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vL1xuLy8gICBSRUFEIFRISVMgRklSU1QgV0hFTiBDSEFOR0lORyBUSElTIEZJTEVcbi8vXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vL1xuLy8gWW91IG5lZWQgKGFuZCBvbmx5IG5lZWQpIHRvIGJ1bXAgdGhlIENMT1VEX0FTU0VNQkxZX1ZFUlNJT04gaWYgdGhlIGNsb3VkXG4vLyBhc3NlbWJseSBuZWVkcyBuZXcgZmVhdHVyZXMgZnJvbSB0aGUgQ0RLIENMSS4gRXhhbXBsZXM6IG5ldyBmaWVsZHMsIG5ld1xuLy8gYmVoYXZpb3IsIG5ldyBhcnRpZmFjdCB0eXBlcy5cbi8vXG4vLyBJZiB0aGF0IGhhcHBlbnMsIHlvdSBzZXQgdGhlIENMT1VEX0FTU0VNQkxZX1ZFUlNJT04gdG8gdGhlICpuZXh0KiAobm90IHRoZVxuLy8gY3VycmVudCEpIENESyB2ZXJzaW9uIHRoYXQgd2lsbCBiZSByZWxlYXNlZC4gVGhpcyBpcyBkb25lIHRvIHByb2R1Y2Vcbi8vIHVzZWZ1bCBlcnJvciBtZXNzYWdlcy5cbi8vXG4vLyBXaGVuIHlvdSBkbyB0aGlzLCB5b3Ugd2lsbCBmb3JjZSB1c2VycyBvZiBhIG5ldyBsaWJyYXJ5IHRvIHVwZ3JhZGUgdGhlIENMSVxuLy8gKGdvb2QpLCBidXQgVU5MRVNTIFlPVSBBTFNPIElNUExFTUVOVCAndXBncmFkZUFzc2VtYmx5TWFuaWZlc3QnIHlvdSB3aWxsIGFsc29cbi8vIGZvcmNlIHBlb3BsZSB3aG8gaGF2ZSBpbnN0YWxsZWQgYSBuZXdlciBDTEkgdG8gdXBncmFkZSB0aGVpciBsaWJyYXJpZXMgKGJhZCEpLlxuLy8gRG8gdGhhdCB0b28sIHVubGVzcyB5b3UgaGF2ZSBhIHZlcnkgZ29vZCByZWFzb24gbm90IHRvLlxuXG4vKipcbiAqIEJ1bXAgdGhpcyB0byB0aGUgbGlicmFyeSB2ZXJzaW9uIGlmIGFuZCBvbmx5IGlmIHRoZSBDWCBwcm90b2NvbCBjaGFuZ2VzLlxuICpcbiAqIFdlIGNvdWxkIGFsc28gaGF2ZSB1c2VkIDEsIDIsIDMsIC4uLiBoZXJlIHRvIGluZGljYXRlIHByb3RvY29sIHZlcnNpb25zLCBidXRcbiAqIHRob3NlIHRoZW4gc3RpbGwgbmVlZCB0byBiZSBtYXBwZWQgdG8gc29mdHdhcmUgdmVyc2lvbnMgdG8gYmUgdXNlZnVsLiBTbyB3ZVxuICogbWlnaHQgYXMgd2VsbCB1c2UgdGhlIHNvZnR3YXJlIHZlcnNpb24gYXMgcHJvdG9jb2wgdmVyc2lvbiBhbmQgaW1tZWRpYXRlbHlcbiAqIGdlbmVyYXRlIGEgdXNlZnVsIGVycm9yIG1lc3NhZ2UgZnJvbSB0aGlzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgdmVyc2lvbnMgYXJlIG5vdCBjb21wYXJlZCBpbiBhIHNlbXZlciB3YXksIHRoZXkgYXJlIHVzZWQgYXNcbiAqIG9wYXF1ZSBvcmRlcmVkIHRva2Vucy5cbiAqL1xuZXhwb3J0IGNvbnN0IENMT1VEX0FTU0VNQkxZX1ZFUlNJT04gPSAnMS4xNi4wJztcblxuLyoqXG4gKiBMb29rIGF0IHRoZSB0eXBlIG9mIHJlc3BvbnNlIHdlIGdldCBhbmQgdXBncmFkZSBpdCB0byB0aGUgbGF0ZXN0IGV4cGVjdGVkIHZlcnNpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeU1hbmlmZXN0VmVyc2lvbihtYW5pZmV0VmVyc2lvbjogc3RyaW5nKSB7XG4gIGNvbnN0IGZyYW1ld29ya1ZlcnNpb24gPSBwYXJzZVNlbXZlcihtYW5pZmV0VmVyc2lvbik7XG4gIGNvbnN0IHRvb2xraXRWZXJzaW9uID0gcGFyc2VTZW12ZXIoQ0xPVURfQVNTRU1CTFlfVkVSU0lPTik7XG5cbiAgLy8gaWYgZnJhbWV3b3JrID4gY2xpLCB3ZSByZXF1aXJlIGEgbmV3ZXIgY2xpIHZlcnNpb25cbiAgaWYgKHNlbXZlci5ndChmcmFtZXdvcmtWZXJzaW9uLCB0b29sa2l0VmVyc2lvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEEgbmV3ZXIgdmVyc2lvbiBvZiB0aGUgQ0RLIENMSSAoPj0gJHtmcmFtZXdvcmtWZXJzaW9ufSkgaXMgbmVjZXNzYXJ5IHRvIGludGVyYWN0IHdpdGggdGhpcyBhcHBgKTtcbiAgfVxuXG4gIC8vIGlmIGZyYW1ld29yayA8IGNsaSwgd2UgcmVxdWlyZSBhIG5ld2VyIGZyYW1ld29yayB2ZXJzaW9uXG4gIGlmIChzZW12ZXIubHQoZnJhbWV3b3JrVmVyc2lvbiwgdG9vbGtpdFZlcnNpb24pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgQ0RLIENMSSB5b3UgYXJlIHVzaW5nIHJlcXVpcmVzIHlvdXIgYXBwIHRvIHVzZSBDREsgbW9kdWxlcyB3aXRoIHZlcnNpb24gPj0gJHtDTE9VRF9BU1NFTUJMWV9WRVJTSU9OfWApO1xuICB9XG59XG5cbi8qKlxuICogVXBncmFkZSBvbGQgbWFuaWZlc3QgdmVyc2lvbnMgdG8gbGF0ZXIgbWFuaWZlc3QgdmVyc2lvbiBoZXJlIChpZiBwb3NzaWJsZSkuXG4gKlxuICogVXNlIHRoaXMgdG8gbWFrZSB0aGUgdG9vbGtpdCByZWNvZ25pemUgb2xkIGFzc2VtYmx5IHZlcnNpb25zLiBUaGlzIGZ1bmN0aW9uIHNob3VsZFxuICogYWRkIG5ld2x5IHJlcXVpcmVkIGZpZWxkcyB3aXRoIGFwcHJvcHJpYXRlIGRlZmF1bHQgdmFsdWVzLCBldGMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGdyYWRlQXNzZW1ibHlNYW5pZmVzdChtYW5pZmVzdDogQXNzZW1ibHlNYW5pZmVzdCk6IEFzc2VtYmx5TWFuaWZlc3Qge1xuXG4gIGlmIChtYW5pZmVzdC52ZXJzaW9uID09PSAnMC4zNi4wJykge1xuICAgIC8vIEFkZGluZyBhIG5ldyBhcnRpZmFjdCB0eXBlLCBvbGQgdmVyc2lvbiB3aWxsIG5vdCBoYXZlIGl0IHNvIHBhaW5sZXNzIHVwZ3JhZGUuXG4gICAgbWFuaWZlc3QgPSBqdXN0VXBncmFkZVZlcnNpb24obWFuaWZlc3QsICcxLjEwLjAnKTtcbiAgfVxuXG4gIGlmIChtYW5pZmVzdC52ZXJzaW9uID09PSAnMS4xMC4wJykge1xuICAgIC8vIFR3byBjaGFuZ2VzOlxuICAgIC8vICogQmFja3dhcmRzLWNvbXBhdGlibGUgY2hhbmdlcyB0byB0aGUgVlBDIHByb3ZpZGVyXG4gICAgLy8gKiBBZGRlZCBBTUkgY29udGV4dCBwcm92aWRlcjogb2xkIGFzc2VtYmxpZXMgd29uJ3QgcmVmZXJlbmNlIGl0LlxuICAgIG1hbmlmZXN0ID0ganVzdFVwZ3JhZGVWZXJzaW9uKG1hbmlmZXN0LCAnMS4xNi4wJyk7XG4gIH1cblxuICByZXR1cm4gbWFuaWZlc3Q7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2VtdmVyKHZlcnNpb246IHN0cmluZykge1xuICBjb25zdCB2ZXIgPSBzZW12ZXIuY29lcmNlKHZlcnNpb24pO1xuICBpZiAoIXZlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHBhcnNlIFwiJHt2ZXJzaW9ufVwiIGFzIHNlbXZlcmApO1xuICB9XG5cbiAgcmV0dXJuIHZlcjtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBjb3B5IG9mIHRoZSBtYW5pZmVzdCB3aXRoIGp1c3QgdGhlIHZlcnNpb24gZmllbGQgdXBkYXRlZFxuICpcbiAqIFVzZWZ1bCBpZiB0aGVyZSBhcmUgcHJvdG9jb2wgY2hhbmdlcyB0aGF0IGFyZSBhdXRvbWF0aWNhbGx5IGJhY2t3YXJkc1xuICogY29tcGF0aWJsZS5cbiAqL1xuZnVuY3Rpb24ganVzdFVwZ3JhZGVWZXJzaW9uKG1hbmlmZXN0OiBBc3NlbWJseU1hbmlmZXN0LCB2ZXJzaW9uOiBzdHJpbmcpOiBBc3NlbWJseU1hbmlmZXN0IHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG1hbmlmZXN0LCB7IHZlcnNpb24gfSk7XG59XG4iXX0=